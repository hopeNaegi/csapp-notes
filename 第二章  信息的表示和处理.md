# 第二章  信息的表示和处理

## 2.1 信息存储

### 2.1.1 十六进制表示法及进制的转换

一个字节由8位组成。以0x开头的数字被认为是十六进制的值，数字中字母大小写不影响。

十六进制转换为二进制
将每一位数字转换为十进制后展开为四位二进制数字。
二进制转换为十六进制
从右向左四位一分隔，最左边不够的用0补齐，按照8421的权重求和后得到对应十六进制数。


二进制数为2^n时的进制转换
1.转换为十进制数
1后面跟n个0
2.转换为十六进制数
n=i+4j，则为2^i后面跟j个0


十进制转化为十六进制
将原数不断除以16，得到余数后由前向后由低到高排列即可
十六进制转换为十进制
根据不同位的权重加权求和即可。

### 2.1.2 字数据大小
字长决定指针数据的标称大小
| 项目 | 32 位系统 | 64 位系统 |
|------|----------|----------|
| 字长（word size） | 32 位 | 64 位 |
| 指针大小 | 4 字节 | 8 字节 |
| 地址表示范围 | 0 ～ 0xFFFFFFFF（4GB） | 0 ～ 0xFFFFFFFFFFFFFFFF（16EB） |
| 同一指针变量 `p` 的 `sizeof(p)` | 4 | 8 |
例如将32位程序的int指针挪用到64位机器上时会崩溃，int类型只有4字节大，而64位下的指针有8字节大。

我们将程序称为 "32 位程序" 或 "64 位程序 " 时，区别在于该程序是如何编译的，
而不是其运行的机器类型。
关键字的顺序可以改变。
### 2.1.3 寻址和字节顺序
对于跨越多字节的的程序对象，需要建立两个规则：1.这个对象的地址是什么2.如何在内存中排列这些字节。  

第一，多字节对象都被存储为连续的字节序列，地址为所用字节的最小地址。  

第二，有两种排列方法。一种将最低有效字节排在前，为小端法，另一种将最高有效字节排在前，为大端法。  

字节顺序在三种情况下会显得重要:  

第一，大小端法机器互传时需要进行转换，否则字节会反序；  

第二，阅读机器级程序，选对应顺序；  

第三，规避正常的类型时：

| 行号 | 代码 |
| ---- | ---- |
| 1    | `#include <stdio.h>` |
| 2    | |
| 3    | typedef[^1] unsigned char *byte_pointer; |
| 4    | |
| 5    | `void show_bytes(byte_pointer start, size_t len) {` |
| 6    | `    size_t i;` |
| 7    | `    for (i = 0; i < len; i++)` |
| 8    | `        printf(" %.2x", start[i]);` |
| 9    | `    printf("\n");` |
| 10   | `}` |
| 11   | |
| 12   | void show_int(int x)[^2] { |
| 13   | `    show_bytes((byte_pointer) &x[^3], sizeof(int));` |
| 14   | `}` |
| 15   | |
| 16   | `void show_float(float x) {` |
| 17   | `    show_bytes((byte_pointer) &x, sizeof(float));` |
| 18   | `}` |
| 19   | |
| 20   | `void show_pointer(void *x) {` |
| 21   | `    show_bytes((byte_pointer) &x, sizeof(void *));` |
| 22   | `}` |
[^1]:用法没有本质区别，只是提升了代码的可读性
[^2]:这些函数都是强制转换类型为byte_pointer
[^3]:printf第一个参数是格式串，%开头则是表示如何格式化下一个参数。例如：
| 格式符 | 含义 |
|--------|------|
| `%d`   | 输出十进制整数 |
| `%f`   | 输出浮点数 |
| `%s`   | 输出字符串 |
| `%x`   | 输出十六进制整数（小写） |
| `%X`   | 输出十六进制整数（大写） |
| `%c`   | 输出单个字符 |

printf("%.2x", 0x3);   // 输出: "03"

printf("%.2x", 0x15);  // 输出: "15"

printf("%.2x", 0x0);   // 输出: "00"
> .2是精度修饰符
### 2.1.4 表示字符串
C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。  
注意，strlen函数不打印空字符。 
### 2.1.5 表示代码
二进制代码是不兼容的。
### 2.1.6 布尔代数

| 布尔运算符号 | 对应逻辑运算 | 命题逻辑符号 | 运算规则（以 P、Q 为逻辑变量） | 二进制值规则（以 p、q 为 0/1 值） |
| --- | --- | --- | --- | --- |
| `~` | NOT（非） | `¬` | 当 P 为假时，`~P` 为真；当 P 为真时，`~P` 为假 | 当 p=0 时，`~p=1`；当 p=1 时，`~p=0` |
| `&` | AND（与） | `∧` | 当且仅当 P 和 Q 都为真时，`P & Q` 为真 | 当且仅当 p=1 且 q=1 时，`p & q=1`，否则为 0 |
| \| | OR（或） | `∨` | 当 P 或 Q 任意一个为真时，`P | Q` 为真 | 当 p=1 或 q=1 时，`p | q=1`，否则为 0 |
| `^` | EXCLUSIVE-OR（异或） | `⊕` | 当 P 和 Q 恰好一个为真时，`P ^ Q` 为真 | 当 p=1 且 q=0，或 p=0 且 q=1 时，`p ^ q=1`，否则为 0 |
对于任意位向量a，都有a^a=0.
### 2.1.7 位级运算
确定一个位级表达式的结果最好的方法,就是将十六进制的参数扩展成二进制表示并执行二进制运算,然后再转换回十六进制。  

位级运算的一个常见用法是**掩码运算**。掩码是一个位模式，通过位运算得到特定的位的集合。  

例如：0xFF[^3]表示获取一个字的最低有效字节。
>1字节 = 8 位 = 2 个十六进制数字。
>所以，两个十六进制数正好表示一个字节。

~0生成一个全为1的掩码，与机器的字长无关，而0xFFFFFFFF在32位机器上与之作用相同，但是不可移植的[^4]。
[^3]:为0x0..011111111.从而前几位位都被变为0，只有最低有效位保留下来。
[^4]:更高位机器将其视为0x0...0FFF   

<img width="554" height="127" alt="image" src="https://github.com/user-attachments/assets/2f3b9fbb-3e72-4722-92d9-2b575365a688" />  
A.x=x&0xFF  B.x=x^~0xFF  C.x=x|0xFF。  
<img width="1171" height="879" alt="image" src="https://github.com/user-attachments/assets/1659632d-7d70-440e-a05a-30974840aba5" />  
/* Declarations of functions implementing operationns bis and bic  

int bis (int x, int m);  

int bic (int x, int m);  

/* Compute x|y using only calls to functions bis and bic /  

int bool_or(int x,int y) {  

int result = **bis(x,y)**   //  *bis(x,y)等价于x|y运算，bic(x,y)等价于x&~y运算*

return result;  

}  

/ Compute x~y using only calls to functions bis andd bic */  
 
int bool_xor(int x, int y) {  

int result =**bis(bic(x,y)，bic(y,x))**  

return result;  
### 2.1.8 逻辑运算
第一，只返回0或1；  
第二，存在短路现象。  
<img width="1145" height="344" alt="image" src="https://github.com/user-attachments/assets/2b299363-58ba-43f7-a81b-38b59103ca75" />   
y=0x00111001  ~y=0x11000110  
x=0x01100110  ~x=0x10011001
|表达式|值|表达式|值|  
|----|----|----|----|  
||0x20||0x01|  
||0x7F||0x01|  
||0xDF||0x00|  
||0x00||0x01|  
<img width="1137" height="123" alt="image" src="https://github.com/user-attachments/assets/f45c311c-0674-474f-8f15-e21fecc60e3c" />  
!(x^y)  //注意：无实际用处
### 2.1.9 移位运算
移位运算分为左移和右移。  
左移指数字整体向左移动n位，并在最右段**补充0**。 
右移分为逻辑右移和算数右移。  
逻辑右移指向右移动n位，并在最左端**补充0**。  
算数右移指向右移动n位，并在最左端**补充最高有效位的值**。  
<img width="795" height="247" alt="image" src="https://github.com/user-attachments/assets/608d6c79-0113-4877-a481-ff2582df793f" />   
//*注意:几乎所有机器对有符号数使用算数右移，而对无符号数必须使用逻辑右移*  
//java中x>>k指算数右移，x>>>k指逻辑右移。
//k过大时，会移动w位的数k mod w个位数  
//移位运算的优先级低于加减法  
## 2.2 整数表示  
### 2.2.1 整型数据类型  
<img width="891" height="445" alt="image" src="https://github.com/user-attachments/assets/a0c9f2e9-4628-4749-b1f8-f1bfe58e9e7b" />  
<img width="1005" height="488" alt="image" src="https://github.com/user-attachments/assets/8fc15a2e-88ac-418f-86c5-5627044d5248" />

//unsigned指非负数，这里给出的只有long的大小和机器有关。  
//正负数的取值范围是不对称的，因为各一半的位模式表示负数和非负数，而0是非负数，所以正数比负数少一个。  

### 2.2.2 无符号数的编码  
<img width="1123" height="437" alt="image" src="https://github.com/user-attachments/assets/f120ee28-4846-4b52-8855-0ad79d90face" />  
<img width="426" height="72" alt="image" src="https://github.com/user-attachments/assets/8c14e993-cddf-49e9-9f76-62b7c3f14019" />  
### 2.2.3补码编码  
<img width="1175" height="468" alt="image" src="https://github.com/user-attachments/assets/abfa2497-23f7-4481-8137-022c740c7fac" /> 
补码编码同样具有唯一性。  
<limits.h>定义了不同整型数据的取值范围，如：INT_MAX,INT_MIN。
<img width="1139" height="592" alt="image" src="https://github.com/user-attachments/assets/9d9e9061-693c-4273-aff4-24bb452e9671" />  

###  2.2.4 有无符号数之间的转换  
注意：位模式没有改变，改变的是解释的方式。  
<img width="1071" height="168" alt="image" src="https://github.com/user-attachments/assets/0874e719-b53c-4ea1-acaf-b1f261fed61f" />  
<img width="1134" height="159" alt="image" src="https://github.com/user-attachments/assets/733f56c3-9cdb-4867-ad37-2b2683a2e0e7" /> 

###  2.2.5 c语言中的有无符号数 
数字常量默认为有符号数，无符号数在末尾带有u或U。  
<img width="1121" height="951" alt="image" src="https://github.com/user-attachments/assets/54f8c67a-8cba-43a1-959d-304f38390ba3" />  
C语言对于同时含有有无符号数的式子，会将有符号数强制转换为无符号数，然后假设二者非负并进行运算。
<img width="1144" height="679" alt="image" src="https://github.com/user-attachments/assets/9cd43a82-322b-4666-a8f4-a2c4c00c57bd" />  
<img width="1136" height="374" alt="image" src="https://github.com/user-attachments/assets/22e37d1c-87ca-4c70-8f54-462983879bac" />  

###  2.2.6 扩展一个数字的位表示 
<img width="1127" height="202" alt="image" src="https://github.com/user-attachments/assets/9f648bf1-1269-4c2a-b09d-9ef249188878" />  
<img width="1106" height="134" alt="image" src="https://github.com/user-attachments/assets/2d350f11-8442-4170-8f91-25a44beb8ef4" />
### 2.2.7 截断数字   

高位数据变量存入低位数据类型时会发生数字截断。    

数字表示方式不同，分为：1.无符号数截断；2.补码(表示有符号数)截断。    

值得注意的是，二者都是直接去掉位向量最高的几位，直接留下最低的k位，区别在于如何解释截断后数，以及截断后的数字和原数的关系。    

设截断后的数为x'，原数为x。     

1.无符号数截断：首先，将截断后的位向量转为无符号数；然后，作为无符号数的原数和截断后数有x'=x mod 2^k 。(因为被截断的w-k位模2^k都等于0.)     

2.补码截断：首先，将原数转为无符号数，再将截断后数转为补码：然后，有x'=U2T~k~(x mod 2^k).    



