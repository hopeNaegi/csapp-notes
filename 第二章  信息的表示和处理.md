# 第二章  信息的表示和处理

## 2.1 信息存储

### 2.1.1 十六进制表示法及进制的转换

一个字节由8位组成。以0x开头的数字被认为是十六进制的值，数字中字母大小写不影响。

十六进制转换为二进制
将每一位数字转换为十进制后展开为四位二进制数字。
二进制转换为十六进制
从右向左四位一分隔，最左边不够的用0补齐，按照8421的权重求和后得到对应十六进制数。


二进制数为2^n时的进制转换
1.转换为十进制数
1后面跟n个0
2.转换为十六进制数
n=i+4j，则为2^i后面跟j个0


十进制转化为十六进制
将原数不断除以16，得到余数后由前向后由低到高排列即可
十六进制转换为十进制
根据不同位的权重加权求和即可。

### 2.1.2 字数据大小
字长决定指针数据的标称大小
| 项目 | 32 位系统 | 64 位系统 |
|------|----------|----------|
| 字长（word size） | 32 位 | 64 位 |
| 指针大小 | 4 字节 | 8 字节 |
| 地址表示范围 | 0 ～ 0xFFFFFFFF（4GB） | 0 ～ 0xFFFFFFFFFFFFFFFF（16EB） |
| 同一指针变量 `p` 的 `sizeof(p)` | 4 | 8 |
例如将32位程序的int指针挪用到64位机器上时会崩溃，int类型只有4字节大，而64位下的指针有8字节大。

我们将程序称为 "32 位程序" 或 "64 位程序 " 时，区别在于该程序是如何编译的，
而不是其运行的机器类型。
关键字的顺序可以改变。
### 2.1.3 寻址和字节顺序
对于跨越多字节的的程序对象，需要建立两个规则：1.这个对象的地址是什么2.如何在内存中排列这些字节。  

第一，多字节对象都被存储为连续的字节序列，地址为所用字节的最小地址。  

第二，有两种排列方法。一种将最低有效字节排在前，为小端法，另一种将最高有效字节排在前，为大端法。  

字节顺序在三种情况下会显得重要:  

第一，大小端法机器互传时需要进行转换，否则字节会反序；  

第二，阅读机器级程序，选对应顺序；  

第三，规避正常的类型时：

| 行号 | 代码 |
| ---- | ---- |
| 1    | `#include <stdio.h>` |
| 2    | |
| 3    | typedef[^1] unsigned char *byte_pointer; |
| 4    | |
| 5    | `void show_bytes(byte_pointer start, size_t len) {` |
| 6    | `    size_t i;` |
| 7    | `    for (i = 0; i < len; i++)` |
| 8    | `        printf(" %.2x", start[i]);` |
| 9    | `    printf("\n");` |
| 10   | `}` |
| 11   | |
| 12   | void show_int(int x)[^2] { |
| 13   | `    show_bytes((byte_pointer) &x[^3], sizeof(int));` |
| 14   | `}` |
| 15   | |
| 16   | `void show_float(float x) {` |
| 17   | `    show_bytes((byte_pointer) &x, sizeof(float));` |
| 18   | `}` |
| 19   | |
| 20   | `void show_pointer(void *x) {` |
| 21   | `    show_bytes((byte_pointer) &x, sizeof(void *));` |
| 22   | `}` |
[^1]:用法没有本质区别，只是提升了代码的可读性
[^2]:这些函数都是强制转换类型为byte_pointer
[^3]:printf第一个参数是格式串，%开头则是表示如何格式化下一个参数。例如：
| 格式符 | 含义 |
|--------|------|
| `%d`   | 输出十进制整数 |
| `%f`   | 输出浮点数 |
| `%s`   | 输出字符串 |
| `%x`   | 输出十六进制整数（小写） |
| `%X`   | 输出十六进制整数（大写） |
| `%c`   | 输出单个字符 |

printf("%.2x", 0x3);   // 输出: "03"

printf("%.2x", 0x15);  // 输出: "15"

printf("%.2x", 0x0);   // 输出: "00"
> .2是精度修饰符
### 2.1.4 表示字符串
C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。  
注意，strlen函数不打印空字符。 
### 2.1.5 表示代码
二进制代码是不兼容的。
### 2.1.6 布尔代数

| 布尔运算符号 | 对应逻辑运算 | 命题逻辑符号 | 运算规则（以 P、Q 为逻辑变量） | 二进制值规则（以 p、q 为 0/1 值） |
| --- | --- | --- | --- | --- |
| `~` | NOT（非） | `¬` | 当 P 为假时，`~P` 为真；当 P 为真时，`~P` 为假 | 当 p=0 时，`~p=1`；当 p=1 时，`~p=0` |
| `&` | AND（与） | `∧` | 当且仅当 P 和 Q 都为真时，`P & Q` 为真 | 当且仅当 p=1 且 q=1 时，`p & q=1`，否则为 0 |
| \| | OR（或） | `∨` | 当 P 或 Q 任意一个为真时，`P | Q` 为真 | 当 p=1 或 q=1 时，`p | q=1`，否则为 0 |
| `^` | EXCLUSIVE-OR（异或） | `⊕` | 当 P 和 Q 恰好一个为真时，`P ^ Q` 为真 | 当 p=1 且 q=0，或 p=0 且 q=1 时，`p ^ q=1`，否则为 0 |
对于任意位向量a，都有a^a=0.
### 2.1.7 位级运算
确定一个位级表达式的结果最好的方法,就是将十六进制的参数扩展成二进制表示并执行二进制运算,然后再转换回十六进制。  

位级运算的一个常见用法是**掩码运算**。掩码是一个位模式，通过位运算得到特定的位的集合。  

例如：0xFF[^3]表示获取一个字的最低有效字节。
>1字节 = 8 位 = 2 个十六进制数字。
>所以，两个十六进制数正好表示一个字节。

~0生成一个全为1的掩码，与机器的字长无关，而0xFFFFFFFF在32位机器上与之作用相同，但是不可移植的[^4]。
[^3]:为0x0..011111111.从而前几位位都被变为0，只有最低有效位保留下来。
[^4]:更高位机器将其视为0x0...0FFF   

<img width="554" height="127" alt="image" src="https://github.com/user-attachments/assets/2f3b9fbb-3e72-4722-92d9-2b575365a688" />  
A.x=x&0xFF  B.x=x^~0xFF  C.x=x|0xFF。  
<img width="1171" height="879" alt="image" src="https://github.com/user-attachments/assets/1659632d-7d70-440e-a05a-30974840aba5" />  
/* Declarations of functions implementing operationns bis and bic  

int bis (int x, int m);  

int bic (int x, int m);  

/* Compute x|y using only calls to functions bis and bic /  

int bool_or(int x,int y) {  

int result = **bis(x,y)**   //  *bis(x,y)等价于x|y运算，bic(x,y)等价于x&~y运算*

return result;  

}  

/ Compute x~y using only calls to functions bis andd bic */  
 
int bool_xor(int x, int y) {  

int result =**bis(bic(x,y)，bic(y,x))**  

return result;  
### 2.1.8 逻辑运算
第一，只返回0或1；  
第二，存在短路现象。  
<img width="1145" height="344" alt="image" src="https://github.com/user-attachments/assets/2b299363-58ba-43f7-a81b-38b59103ca75" />   
y=0x00111001  ~y=0x11000110  
x=0x01100110  ~x=0x10011001
|表达式|值|表达式|值|  
|----|----|----|----|  
||0x20||0x01|  
||0x7F||0x01|  
||0xDF||0x00|  
||0x00||0x01|  
<img width="1137" height="123" alt="image" src="https://github.com/user-attachments/assets/f45c311c-0674-474f-8f15-e21fecc60e3c" />  
!(x^y)  //注意：无实际用处
### 2.1.9 移位运算
移位运算分为左移和右移。  
左移指数字整体向左移动n位，并在最右段**补充0**。 
右移分为逻辑右移和算数右移。  
逻辑右移指向右移动n位，并在最左端**补充0**。  
算数右移指向右移动n位，并在最左端**补充最高有效位的值**。  
<img width="795" height="247" alt="image" src="https://github.com/user-attachments/assets/608d6c79-0113-4877-a481-ff2582df793f" />   
//*注意:几乎所有机器对有符号数使用算数右移，而对无符号数必须使用逻辑右移*  
//java中x>>k指算数右移，x>>>k指逻辑右移。
//k过大时，会移动w位的数k mod w个位数  
//移位运算的优先级低于加减法  
## 2.2 整数表示  
### 2.2.1 整型数据类型  
<img width="891" height="445" alt="image" src="https://github.com/user-attachments/assets/a0c9f2e9-4628-4749-b1f8-f1bfe58e9e7b" />  
<img width="1005" height="488" alt="image" src="https://github.com/user-attachments/assets/8fc15a2e-88ac-418f-86c5-5627044d5248" />

//unsigned指非负数，这里给出的只有long的大小和机器有关。  
//正负数的取值范围是不对称的，因为各一半的位模式表示负数和非负数，而0是非负数，所以正数比负数少一个。  

### 2.2.2 无符号数的编码  
<img width="1123" height="437" alt="image" src="https://github.com/user-attachments/assets/f120ee28-4846-4b52-8855-0ad79d90face" />  
<img width="426" height="72" alt="image" src="https://github.com/user-attachments/assets/8c14e993-cddf-49e9-9f76-62b7c3f14019" />  
### 2.2.3补码编码  
<img width="1175" height="468" alt="image" src="https://github.com/user-attachments/assets/abfa2497-23f7-4481-8137-022c740c7fac" /> 
补码编码同样具有唯一性。  
<limits.h>定义了不同整型数据的取值范围，如：INT_MAX,INT_MIN。
<img width="1139" height="592" alt="image" src="https://github.com/user-attachments/assets/9d9e9061-693c-4273-aff4-24bb452e9671" />  

###  2.2.4 有无符号数之间的转换  
注意：位模式没有改变，改变的是解释的方式。  
<img width="1071" height="168" alt="image" src="https://github.com/user-attachments/assets/0874e719-b53c-4ea1-acaf-b1f261fed61f" />  
<img width="1134" height="159" alt="image" src="https://github.com/user-attachments/assets/733f56c3-9cdb-4867-ad37-2b2683a2e0e7" /> 

###  2.2.5 c语言中的有无符号数 
数字常量默认为有符号数，无符号数在末尾带有u或U。  
<img width="1121" height="951" alt="image" src="https://github.com/user-attachments/assets/54f8c67a-8cba-43a1-959d-304f38390ba3" />  
C语言对于同时含有有无符号数的式子，会将有符号数强制转换为无符号数，然后假设二者非负并进行运算。
<img width="1144" height="679" alt="image" src="https://github.com/user-attachments/assets/9cd43a82-322b-4666-a8f4-a2c4c00c57bd" />  
<img width="1136" height="374" alt="image" src="https://github.com/user-attachments/assets/22e37d1c-87ca-4c70-8f54-462983879bac" />  

###  2.2.6 扩展一个数字的位表示 
<img width="1127" height="202" alt="image" src="https://github.com/user-attachments/assets/9f648bf1-1269-4c2a-b09d-9ef249188878" />  
<img width="1106" height="134" alt="image" src="https://github.com/user-attachments/assets/2d350f11-8442-4170-8f91-25a44beb8ef4" />
### 2.2.7 截断

#### 原理：截断无符号数
将一个 $ w $ 位无符号数 $ x = [x_{w-1}, x_{w-2}, \dots, x_0] $ 截断为 $ k $ 位（$ k < w $），得到 $ x' = B2U_k(\lfloor x / 2^{w-k} \rfloor) $。  
等价于：
$$
x' = x \mod 2^k
$$

> 因为被丢弃的高位权值均为 $ 2^i $（其中 $ i \geq k $），在模 $ 2^k $ 下都为 0。

#### 推导：截断无符号数
$$
\begin{aligned}
B2U_w([x_{w-1},\dots,x_0]) \mod 2^k &= \left[\sum_{i=0}^{w-1} x_i 2^i\right] \mod 2^k \\
&= \left[\sum_{i=0}^{k-1} x_i 2^i\right] \mod 2^k \\
&= B2U_k([x_{k-1},\dots,x_0])
\end{aligned}
$$

#### 原理：截断补码数值
对于有符号数 $ x = B2T_w(\bar{x}) $，其截断结果为：
$$
x' = U2T_k(x \mod 2^k)
$$

> 即先对 $ x $ 取模 $ 2^k $ 得到无符号数，再解释为 $ k $ 位补码。

#### 推导：截断补码数值
$$
B2U_w([x_{w-1},\dots,x_0]) \mod 2^k = B2U_k([x_{k-1},\dots,x_0])
$$
因此：
$$
B2T_k([x_{k-1},\dots,x_0]) = B2U_k([x_{k-1},\dots,x_0]) \mod 2^k
$$

> 补码截断相当于先转为无符号数截断，再转回补码。

---

### 练习题 2.24

将一个 4 位十六进制数（0~F）截断到 3 位，填表如下：

| 十六进制 | 原始值 | 截断值（无符号） | 原始值（补码） | 截断值（补码） |
|----------|--------|------------------|----------------|----------------|
| 0        | 0      | 0                | 0              | 0              |
| 2        | 2      | 2                | -6             | -6             |
| 9        | 9      | 1                | -7             | -7             |
| B        | 11     | 3                | -5             | -5             |
| F        | 15     | 7                | -1             | -1             |

> **说明**：  
> - 无符号截断：直接保留低 3 位，结果为 $ x \mod 8 $  
> - 补码截断：先转为无符号截断，再解释为 3 位补码（范围 -4 ~ 3）

---

### 2.2.8 关于有符号数与无符号数的建议

#### 隐式类型转换问题
C 语言中，有符号数到无符号数的隐式强制类型转换会导致非直观行为，容易引发错误。

##### 示例代码（练习题 2.25）
```c
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;
    for (i = 0; i <= length-1; i++)
        result += a[i];
    return result;
}
```

当 `length = 0` 时，`i <= -1` 成立，导致无限循环。

> **原因**：`unsigned length = 0` → `length - 1 = UINT_MAX`，所以 `i <= length-1` 永远成立。

**修复方法**：将比较改为 `i < length`，或显式声明 `length` 为 `int`。

---

### 练习题 2.26

函数判断字符串是否更长：
```c
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```

#### 问题分析
- `size_t` 是无符号类型（通常是 `unsigned int`）
- 若 `strlen(s) < strlen(t)`，则 `strlen(s) - strlen(t)` 会溢出为一个很大的正数
- 导致返回 `true`，即使 `s` 更短

 **修复方法**：避免负数减法，改用：
```c
return strlen(s) > strlen(t);
```

---

###注：函数 getpeername 的安全漏洞

#### 漏洞描述
FreeBSD 中的 `copy_from_kernel` 函数：
```c
int copy_from_kernel(void *user_dest, int maxlen) {
    int len = KSIZE < maxlen ? KSIZE : maxlen;
    memcpy(user_dest, kbuf, len);
    return len;
}
```

若 `maxlen` 为负数（如 `-1`），由于 `maxlen` 是 `int` 类型，而 `len` 被声明为 `int`，但 `memcpy` 的长度参数是 `size_t`（无符号），会被解释为极大正数（如 $ 2^{32}-1 $），造成缓冲区溢出。

#### 修复建议
- 将 `maxlen` 和 `len` 声明为 `size_t`
- 保持类型一致性，避免符号不匹配

---

###2.3 整数运算

许多程序员惊讶地发现：两个正数相加可能得负数，比较表达式 `x < y` 和 `x - y < 0` 结果不同。这是由于**整数运算的有限性**造成的。

---

###2.3.1 无符号加法

#### 原理：无符号加法
对满足 $ 0 \leq x, y < 2^w $ 的数：
$$
x +_w y = 
\begin{cases}
x + y, & x + y < 2^w \quad \text{(正常)}\\
x + y - 2^w, & x + y \geq 2^w \quad \text{(溢出)}
\end{cases}
$$

> 等价于模 $ 2^w $ 加法。

#### 图 2-23：无符号加法（4 位字长）
- 当 $ x + y < 16 $：正常
- 当 $ x + y \geq 16 $：溢出，结果减去 16

#### 溢出检测
- 若 $ s = x + y $，且 $ s < x $ 或 $ s < y $，则发生溢出
- 否则未溢出

#### 练习题 2.27
实现函数检测无符号加法是否溢出：
```c
int uadd_ok(unsigned x, unsigned y) {
    return x <= UINT_MAX - y;
}
```

---

### 练习题 2.28

求 4 位无符号数的加法逆元（即 $ -_w x $）：

| x（十六进制） | x（十进制） | $-_w x$（十进制） | $-_w x$（十六进制） |
|---------------|-------------|--------------------|-----------------------|
| 0             | 0           | 0                  | 0                     |
| 5             | 5           | 11                 | B                     |
| 8             | 8           | 8                  | 8                     |
| D             | 13          | 3                  | 3                     |
| F             | 15          | 1                  | 1                     |

> 公式：$ -_w x = 
\begin{cases}
0, & x = 0\\
2^w - x, & x > 0
\end{cases} $

---

###2.3.2 补码加法

#### 原理：补码加法
对满足 $ -2^{w-1} \leq x, y \leq 2^{w-1}-1 $ 的数：
$$
x +_w y = 
\begin{cases}
x + y - 2^w, & x + y \geq 2^{w-1} \quad \text{(正溢出)}\\
x + y, & -2^{w-1} \leq x + y < 2^{w-1} \quad \text{(正常)}\\
x + y + 2^w, & x + y < -2^{w-1} \quad \text{(负溢出)}
\end{cases}
$$

#### 图 2-26：补码加法（4 位）
- 正溢出：和 ≥ 8 → 结果减 16
- 负溢出：和 < -8 → 结果加 16

#### 溢出检测
- 正溢出：$ x > 0, y > 0, s \leq 0 $
- 负溢出：$ x < 0, y < 0, s \geq 0 $

#### 练习题 2.29
根据图 2-25 填写表格（略）

#### 练习题 2.30
实现补码加法溢出检测：
```c
int tadd_ok(int x, int y) {
    int sum = x + y;
    return (sum >= x && sum >= y) || (sum <= x && sum <= y);
}
```

> 或者更简洁：
```c
return (x > 0 && y > 0 && sum < 0) || (x < 0 && y < 0 && sum >= 0) ? 0 : 1;
```

---

### 练习题 2.31

给出的代码：
```c
int tadd_ok(int x, int y) {
    int sum = x + y;
    return (sum - x == y) && (sum - y == x);
}
```

#### 错误分析
- 当 `x = INT_MIN`, `y = 1` 时，`sum = INT_MIN + 1`，但 `sum - x = 1`，看似正确
- 但如果 `x = INT_MAX`, `y = 1`，`sum` 溢出，`sum - x` 不等于 `y`
- 更严重的是：**当 `x = INT_MIN`, `y = INT_MIN` 时，`sum` 溢出，`sum - x` 是未定义行为**

 **正确版本**：
```c
int tadd_ok(int x, int y) {
    long long sum = (long long)x + y;
    return sum >= INT_MIN && sum <= INT_MAX;
}
```

---

###  2.3.3 补码的非

#### 原理：补码的非
对 $ TMin_w \leq x \leq TMax_w $，其补码的非为：
$$
-_w x = 
\begin{cases}
TMin_w, & x = TMin_w\\
-x, & x > TMin_w
\end{cases}
$$

> 特别地，$ -TMin_w $ 无法表示，因此 $ -_w TMin_w = TMin_w $

####  练习题 2.33

求 4 位补码的加法逆元：

| x（十六进制） | x（十进制） | $-_w x$（十进制） | $-_w x$（十六进制） |
|---------------|-------------|--------------------|-----------------------|
| 0             | 0           | 0                  | 0                     |
| 5             | 5           | -5                 | B                     |
| 8             | 8           | -8                 | 8                     |
| D             | -3          | 3                  | 3                     |
| F             | -1          | 1                  | 1                     |

> 观察：除了 `TMin_w = 8`（即 -8），其余都是普通取反。

---

###  网络旁注：DATA:TNEG —— 补码非的位级表示

#### 方法一：逐位取反 + 1
- 对任意整数 $ x $，$ -x = \sim x + 1 $

####  方法二：分两部分计算
设 $ x = [x_{w-1}, x_{w-2}, \dots, x_k, 1, 0, \dots, 0] $，则：
$$
-\tilde{x} = [\sim x_{w-1}, \sim x_{w-2}, \dots, \sim x_k, 0, 1, \dots, 1]
$$

> 例如：`0x0a`（10）→ `0xf5` → `0xf6`（-10）

---

###  总结要点

| 主题 | 核心结论 |
|------|---------|
| **截断** | 无符号/补码截断都等价于模运算 |
| **溢出** | 无符号溢出为“绕回”，补码溢出影响符号 |
| **加法** | 无符号加法是模 $ 2^w $，补码加法是模 $ 2^w $ 但需考虑符号 |
| **类型转换** | 有符号转无符号可能导致逻辑错误 |
| **安全编程** | 注意 `size_t` 与 `int` 类型不匹配的风险 |

---

>  **关键提醒**：  
> 在 C 中，**不要依赖隐式类型转换**，尤其是涉及 `unsigned` 和 `signed` 的混合运算。  
> 使用 `size_t` 时要特别小心，避免负数参与比较。

### 2.3.4 无符号乘法

范围在 $0 \leq x, y \leq 2^w - 1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x \cdot y$ 的取值范围为 $0$ 到 $(2^w - 1)^2 = 2^{2w} - 2^{w+1} + 1$ 之间。这可能需要 $2w$ 位来表示。不过，C 语言中的无符号乘法被定义为产生 $w$ 位的值，就是 $2w$ 位的整数乘积的低 $w$ 位表示的值。我们将这个值表示为 $x * _u y$。

将一个无符号数截断为 $w$ 位等价于计算该值模 $2^w$，得到：

**原理：无符号乘法**

对满足 $0 \leq x, y \leq UMax_w$ 的 $x$ 和 $y$ 有：
$$
x * _u y = (x \cdot y) \mod 2^w \tag{2.16}
$$

---

### 2.3.5 补码乘法

范围在 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的补码数字，但是它们的乘积 $x \cdot y$ 的取值范围为 $-2^{w-1} \cdot (2^{w-1} - 1) = -2^{2w-2} + 2^{w-1}$ 到 $-2^{w-1} \cdot -2^{w-1} = -2^{2w-2}$ 之间。想要用补码来表示这个乘积，可能需要 $2w$ 位。然而，C 语言中的有符号乘法是通过将 $2w$ 位的乘积截断为 $w$ 位来实现的。我们将这个数值表示为 $x * _s y$。将一个补码数截断为 $w$ 位相当于先计算该值模 $2^w$，再把无符号数转换为补码，得到：

**原理：补码乘法**

对满足 $TMin_w \leq x, y \leq TMax_w$ 的 $x$ 和 $y$ 有：
$$
x * _s y = U2T_w((x \cdot y) \mod 2^w) \tag{2.17}
$$

我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的，并用如下原理说明：

**原理：无符号和补码乘法的位级等价性**

给定长度为 $w$ 的位向量 $\bar{x}$ 和 $\bar{y}$，用补码形式的位向量表示来定义整数 $x$ 和 $y$：$x = B2T_w(\bar{x})$, $y = B2T_w(\bar{y})$。用无符号形式的位向量表示来定义非负整数 $x'$ 和 $y'$：$x' = B2U_w(\bar{x})$, $y' = B2U_w(\bar{y})$。则
$$
T2B_w(x * _s y) = U2B_w(x' * _u y')
$$

作为说明，图 2-27 给出了不同 3 位数字的乘法结果。对于每一对位级运算数，我们执行无符号和补码乘法，得到 6 位的乘积，然后再把这些乘积截断到 3 位。无符号的截断后的乘积总是等于 $x \cdot y \mod 8$。虽然无符号和补码两种乘法乘积的 6 位表示不同，但是截断后的乘积的位级表示相同。

**推导：无符号和补码乘法的位级等价性**

根据等式 (2.6)，我们有 $x' = x + x_{w-1} \cdot 2^w$ 和 $y' = y + y_{w-1} \cdot 2^w$。计算这些值的乘积模 $2^w$ 得到以下结果：
$$
(x' \cdot y') \mod 2^w = [(x + x_{w-1} \cdot 2^w) \cdot (y + y_{w-1} \cdot 2^w)] \mod 2^w
$$
$$
= [x \cdot y + (x_{w-1} \cdot y + y_{w-1} \cdot x) \cdot 2^w + x_{w-1} \cdot y_{w-1} \cdot 2^{2w}] \mod 2^w \tag{2.18}
$$
$$
= (x \cdot y) \mod 2^w
$$

由于模运算符，所有带有权重 $2^w$ 和 $2^{2w}$ 的项都丢掉了。根据等式 (2.17)，我们有 $x * _s y = U2T_w((x \cdot y) \mod 2^w)$。对等式两边应用操作 $T2U_w$ 有：
$$
T2U_w(x * _s y) = T2U_w(U2T_w((x \cdot y) \mod 2^w)) = (x \cdot y) \mod 2^w
$$

将上述结果与式 (2.16) 和 (2.18) 结合起来得到 $T2U_w(x * _s y) = (x' \cdot y') \mod 2^w = x' * _u y'$。然后对这个等式的两边应用 $U2B_w$，得到：
$$
U2B_w(T2U_w(x * _s y)) = T2B_w(x * _s y) = U2B_w(x' * _u y')
$$

| 模式 | $x$ | $y$ | $x \cdot y$ | 截断的 $x \cdot y$ |
|------|-----|-----|-------------|------------------|
| 无符号 | 5 | [101] | 3 | [011] | 15 | [001111] | 7 | [111] |
| 补码 | -3 | [101] | 3 | [011] | -9 | [110111] | -1 | [111] |
| 无符号 | 4 | [100] | 7 | [111] | 28 | [011100] | 4 | [100] |
| 补码 | -4 | [100] | -1 | [111] | 4 | [001000] | -4 | [100] |
| 无符号 | 3 | [011] | 3 | [011] | 9 | [001001] | 1 | [001] |
| 补码 | 3 | [011] | 3 | [011] | 9 | [001001] | 1 | [001] |

> 图 2-27 3 位无符号和补码乘法示例。虽然完整的乘积的位级表示可能会不同，但是截断后乘积的位级表示是相同的。

---

### 练习题 2.34

按照图 2-27 的风格填写下表，说明不同的 3 位数字乘法的结果。

| 模式 | $x$ | $y$ | $x \cdot y$ | 截断的 $x \cdot y$ |
|------|-----|-----|-------------|------------------|
| 无符号 | [100] | [101] | | |
| 补码 | [100] | [101] | | |
| 无符号 | [010] | [111] | | |
| 补码 | [010] | [111] | | |
| 无符号 | [110] | [110] | | |
| 补码 | [110] | [110] | | |

---

### 练习题 2.35

给你一个任务，开发函数 `tmult_ok` 的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案：

```c
/* Determine whether arguments can be multiplied without overflow */
int tmult_ok(int x, int y) {
    int p = x * y;
    /* Either x is zero, or dividing p by x gives y */
    return !x || p / x == y;
}
```

你用 $x$ 和 $y$ 的很多值来测试这段代码，似乎都工作正常。你的同事挑战你，说：“如果我不能用减法来检验加法是否溢出（参见练习题 2.31），那么你怎么能用除法来检验乘法是否溢出呢？”

按照你的思路，用数学推导来证明你的方法是对的。首先，证明 $x = 0$ 的情况是正确的。另外，考虑 $w$ 位数字 $x (x \neq 0)$、$y$、$p$ 和 $q$，这里 $p$ 是 $x$ 和 $y$ 补码乘法的结果，而 $q$ 是 $p$ 除以 $x$ 的结果。

1) 说明 $x$ 和 $y$ 的整数乘积 $x \cdot y$，可以写成这样的形式：$x \cdot y = p + t \cdot 2^w$，其中，$t \neq 0$ 当且仅当 $p$ 的计算溢出。

2) 说明 $p$ 可以写成这样的形式：$p = x \cdot q + r$，其中 $|r| < |x|$。

3) 说明 $q = y$ 当且仅当 $r = t = 0$。

---

### 练习题 2.36

对于数据类型 `int` 为 32 位的情况，设计一个版本的 `tmult_ok` 函数（练习题 2.35），使用 64 位精度的数据类型 `int64_t`，而不使用除法。

---

### 旁注 XDR 库中的安全漏洞

2002 年，人们发现 Sun Microsystems 公司提供的实现 XDR 库的代码有安全漏洞，XDR 库是一个广泛使用的、程序间共享数据结构的工具，造成这个安全漏洞的原因是程序会在毫无察觉的情况下产生乘法溢出。

包含安全漏洞的代码与下面所示类似：

```c
/* Illustration of code vulnerability similar to that found in
 * Sun's XDR library.
 */
void* copy_elements(void *ele_src[], int ele_cnt, size_t ele_size) {
    /* Allocate buffer for ele_cnt objects, each of ele_size bytes
     * and copy from locations designated by ele_src
     */
    void *result = malloc(ele_cnt * ele_size);
    if (result == NULL)
        /* malloc failed */
        return NULL;
    void *next = result;
    int i;
    for (i = 0; i < ele_cnt; i++) {
        /* Copy object i to destination */
        memcpy(next, ele_src[i], ele_size);
        /* Move pointer to next memory region */
        next += ele_size;
    }
    return result;
}
```

函数 `copy_elements` 设计用来将 `ele_cnt` 个数据结构复制到第 9 行的函数分配的缓冲区中，每个数据结构包含 `ele_size` 个字节。需要的字节数是通过计算 `ele_cnt * ele_size` 得到的。

想看一下，一个怀有恶意的程序员在被编译为 32 位的程序中用参数 `ele_cnt` 等于 $1048577 (2^{20} + 1)$，`ele_size` 等于 $4096 (2^{12})$ 来调用这个函数。然后第 9 行上的乘法会溢出，导致只会分配 4096 个字节，而不是装下这些数据所需要的 4 294 971 392 个字节。从第 15 行开始的循环会试图复制所有的字节，超越已分配的缓冲区的界限，因而破坏了其他的数据库结构。这会导致程序崩溃或者行为异常。

几乎每个操作系统都使用了这段 Sun 的代码，像 Internet Explorer 和 Kerberos 验证系统这样使用广泛的程序都用到了它。计算机紧急响应组（Computer Emergency Response Team，CERT），由卡内基-梅隆软件工程协会（Carnegie Mellon Software Engineering Institute）运作的一个追踪安全漏洞或失效的组织，发布了建议 “CA-2002-25”，于是许多公司急忙对它们的代码打补丁。幸运的是，还没有由于这个漏洞引起的安全失败的报告。

库函数 `calloc` 的实现中存在着类似的漏洞。这些已经被修补过了。遗憾的是，许多程序员调用分配函数（如 `malloc`）时，使用算术表达式作为参数，并且不对这些表达式进行溢出检查。编写 `calloc` 的可靠版本留作一道练习题（家庭作业 2.76）。

---

### 练习题 2.37

现在你有一个任务，当数据类型 `int` 和 `size_t` 都是 32 位的，修补上述旁注给出的 XDR 代码中的漏洞。你决定将待分配字节数设置为数据类型 `uint64_t`，来消除乘法溢出的可能性。你把原来对 `malloc` 函数的调用（第 9 行）替换如下：

```c
uint64_t asize = ele_cnt * (uint64_t) ele_size;
void *result = malloc(asize);
```

提醒一下，`malloc` 的参数类型是 `size_t`。

A. 这段代码对原始的代码有了哪些改进？

B. 你该如何修改代码来消除这个漏洞？

---

### 2.3.6 乘以常数

以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要 1 个时钟周期。即使在我们的参考机器 Intel Core i7 Haswell 上，其整数乘法也需要 3 个时钟周期。因此，编译器使用了一项重要的优化，试用用移位和加法运算的组合来代替乘以常数因子的乘法。首先，我们会考虑乘以 2 的幂的情况，然后再概括成乘以任意常数。

**原理：乘以 2 的幂**

设 $x$ 为位模式 $[x_{w-1}, x_{w-2}, \cdots, x_0]$ 表示的无符号整数。那么，对于任何 $k \geq 0$，我们都认为 $[x_{w-1}, x_{w-2}, \cdots, x_0, 0, \cdots, 0]$ 给出了 $x \cdot 2^k$ 的 $w+k$ 位的无符号表示，这里右边增加了 $k$ 个 0。

因此，比如，当 $w = 4$ 时，11 可以被表示为 $[1011]$。$k = 2$ 时将其左移得到 6 位向量 $[101100]$，即可编码为无符号数 $11 \cdot 4 = 44$。

**推导：乘以 2 的幂**

这个属性可以通过等式 (2.1) 推导出来：

$$
B2U_{w+k}([x_{w-1}, x_{w-2}, \cdots, x_0, 0, \cdots, 0]) = \sum_{i=0}^{w-1} x_i 2^{i+k}
= \left[\sum_{i=0}^{w-1} x_i 2^i\right] \cdot 2^k
= x \cdot 2^k
$$

当对固定字长左移 $k$ 位时，其高 $k$ 位被丢弃，得到
$$
[x_{w-1}, x_{w-2}, \cdots, x_0, 0, \cdots, 0]
$$

而执行固定字长的乘法也是这种情况。因此，我们可以看出左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。

**原理：与 2 的幂相乘的无符号乘法**

C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$，且 $0 \leq k < w$，则 C 表达式 $x << k$ 产生数值 $x * _u 2^k$。

由于固定大小的补码算术运算的位级操作与其无符号运算等价，我们就可以对补码运算的 2 的幂的乘法与左移之间的关系进行类似的叙述：

**原理：与 2 的幂相乘的补码乘法**

C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0 \leq k < w$，则 C 表达式 $x << k$ 产生数值 $x * _s 2^k$。

注意，无论是无符号运算还是补码运算，乘以 2 的幂都可能会导致溢出。结果表明，即使溢出的时候，我们通过移位得到的结果也是一样的。回到前面的例子，我们将 4 位模式 $[1011]$（数值为 11）左移两位得到 $[101100]$（数值为 44）。将这个值截断为 4 位得到 $[1100]$（数值为 12 = 44 mod 16）。

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和减法的组合来简化整数乘以常数的情况。例如，假设一个程序包含表达式 $x * 14$。利用 $14 = 2^3 + 2^2 + 2^1$，编译器会将乘法重写为 $(x << 3) + (x << 2) + (x << 1)$，将一个乘法替换为三个移位和两个加法。无论 $x$ 是无符号的还是补码，甚至当乘法会导致溢出时，两个计算都会得到一样的结果。（根据整数运算的属性可以证明这一点。）更好的是，编译器还可以利用属性 $14 = 2^4 - 2^1$，将乘法重写为 $(x << 4) - (x << 1)$，这时只需要两个移位和一个减法。

---

### 练习题 2.38

就像我们将在第 3 章中看到的那样，LEA 指令能够执行形如 $(a << k) + b$ 的计算，这里 $k$ 等于 0、1、2 或 3，而 $b$ 等于 0 或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用 $(a << 1) + a$ 来计算 $3*a$。

考虑 $b$ 等于 0 或者等于 $a$、$k$ 为任意可能的值的情况，用一条 LEA 指令可以计算 $a$ 的哪些倍数？

归纳一下我们的例子，考虑一个任务，对于某个常数 $K$ 的表达式 $x * K$ 生成代码。编译器会将 $K$ 的二进制表示表达为一组 0 和 1 交替的序列：
$$
[(1(0\cdots0)(111)(0\cdots1)\cdots(1\cdots1)]
$$

例如，14 可以写成 $[0(0\cdots0)(111)(0)]$。考虑一组从位位置 $n$ 到位位置 $m$ 的连续的 1 ($n \geq m$)。（对于 14 来说，我们有 $n = 3$ 和 $m = 1$。）我们可以用下面两种不同形式中的一种来计算这些位对乘积的影响：

- 形式 A：$(x << n) + (x << (n-1)) + \cdots + (x << m)$
- 形式 B：$(x << (n+1)) - (x << m)$

把每个这样连续的 1 的结果加起来，不用做任何乘法，我们就能计算出 $x * K$。当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化。

---

### 练习题 2.39

对于位位置 $n$ 为最高有效位的情况，我们要怎样修改形式 B 的表达式？

---

### 练习题 2.40

对于下面每个 $K$ 的值，找出只用指定数量的运算表达 $x * K$ 的方法，这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式 A 和 B 原则，你可能需要使用一些技巧。

| $K$ | 移位 | 加法/减法 | 表达式 |
|-----|------|-----------|--------|
| 6   | 2    | 1         |        |
| 31  | 1    | 1         |        |
| -6  | 2    | 1         |        |
| 55  | 2    | 2         |        |

---

### 练习题 2.41

对于一组从位位置 $n$ 开始到位位置 $m$ 的连续的 1 ($n \geq m$)，我们看到可以产生两种形式的代码，A 和 B。编译器该如何决定使用哪一种呢？

---

### 2.3.7 除以 2 的幂

在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的时钟周期。除以 2 的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。无符号和补码分别使用逻辑右移和算术移位来达到目的。

整数除法总是舍入到零。为了准确进行定义，我们要引入一些符号。对于任何实数 $a$，定义 $\lfloor a \rfloor$ 为唯一的整数 $a'$，使得 $a' \leq a < a'+1$。例如，$\lfloor 3.14 \rfloor = 3$，$\lfloor -3.14 \rfloor = -4$，而 $\lceil 3 \rceil = 3$。同样，定义 $\lceil a \rceil$ 为唯一的整数 $a'$，使得 $a'-1 < a \leq a'$。例如，$\lceil 3.14 \rceil = 4$，$\lceil -3.14 \rceil = -3$，而 $\lceil 3 \rceil = 3$。对于 $x \geq 0$ 和 $y > 0$，结果会是 $\lfloor x/y \rfloor$，而对于 $x < 0$ 和 $y > 0$，结果会是 $\lceil x/y \rceil$。也就是说，它将向下舍入一个正值，而向上舍入一个负值。

对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移。

**原理：除以 2 的幂的无符号除法**

C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$，且 $0 \leq k < w$，则 C 表达式 $x >> k$ 产生数值 $\lfloor x / 2^k \rfloor$。

例如，图 2-28 给出了在 12 340 的 16 位表示上执行逻辑右移的结果，以及对它执行除以 1、2、16 和 256 的结果。从左端移入的 0 以斜体表示。我们还给出了用真正的运算做除法得到的结果。这些示例说明，移位总是舍入到零的结果，这一点与整数除法的规则一样。

| $k$ | $>> k$（二进制） | 十进制 | $12340 / 2^k$ |
|-----|------------------|--------|----------------|
| 0   | 0011000001101100 | 12340  | 12340.0        |
| 1   | 0001100000110110 | 6170   | 6170.0         |
| 4   | 0000011000001101 | 771    | 771.25         |
| 8   | 0000000011000001 | 48     | 48.203125      |

> 图 2-28 无符号数除以 2 的幂（这个例子说明了执行一个逻辑右移 $k$ 位与除以 $2^k$ 再舍入到零有一样的效果）

**推导：除以 2 的幂的无符号除法**

设 $x$ 为位模式 $[x_{w-1}, x_{w-2}, \cdots, x_0]$ 表示的无符号整数，而 $k$ 的取值范围为 $0 \leq k < w$。设 $x'$ 为 $w-k$ 位表示 $[x_{w-1}, x_{w-2}, \cdots, x_k]$ 的无符号数，而 $x''$ 为 $k$ 位表示 $[x_{k-1}, \cdots, x_0]$ 的无符号数。由此，我们可以看到 $x = 2^k x' + x''$，而 $0 \leq x'' < 2^k$。因此，可得 $\lfloor x / 2^k \rfloor = x'$。

对位向量 $[x_{w-1}, x_{w-2}, \cdots, x_0]$ 逻辑右移 $k$ 位会得到位向量
$$
[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_k]
$$

这个位向量有数值 $x'$，我们看到，该值可以通过计算 $x >> k$ 得到。

对于除以 2 的幂的补码运算来说，情况要稍微复杂一些。首先，为了保证负数仍然为负，移位要执行的是算术右移。现在让我们来看这种右移会产生什么结果。

**原理：除以 2 的幂的补码除法，向下舍入**

C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0 \leq k < w$，则当执行算术移位时，C 表达式 $x >> k$ 产生数值 $\lfloor x / 2^k \rfloor$。

对于 $x >> k$ 的最高位的值为 0，所以效果与逻辑右移是一样的。因此，对于非负数来说，算术右移 $k$ 位与除以 $2^k$ 是一样的。作为一个负数的例子，图 2-29 给出了对 $-12340$ 的 16 位表示进行算术右移不同位数的结果。对于不需要舍入的情况 ($k = 1$)，结果是 $x / 2^k$。但是当需要进行舍入时，移位导致结果向下舍入。例如，右移 4 位将会把 $-771.25$ 向下舍入为 $-772$。我们需要调整策略来处理负数 $x$ 的除法。

| $k$ | $>> k$（二进制） | 十进制 | $-12340 / 2^k$ |
|-----|------------------|--------|----------------|
| 0   | 1100111110011100 | -12340 | -12340.0       |
| 1   | 1110011111001110 | -6170  | -6170.0        |
| 4   | 1111100111110011 | -772   | -771.25        |
| 8   | 1111111110011111 | -48    | -48.203125     |

> 图 2-29 进行算术右移（这个例子说明了算术右移类似于除以 2 的幂，除了是向下舍入，而不是向零舍入）

**推导：除以 2 的幂的补码除法，向下舍入**

设 $x$ 为位模式 $[x_{w-1}, x_{w-2}, \cdots, x_0]$ 表示的补码整数，而 $k$ 的取值范围为 $0 \leq k < w$。设 $x'$ 为 $w-k$ 位 $[x_{w-1}, x_{w-2}, \cdots, x_k]$ 表示的补码数，而 $x''$ 为低 $k$ 位 $[x_{k-1}, \cdots, x_0]$ 表示的无符号数。通过与对无符号情况类似的分析，我们有 $x = 2^k x' + x''$，而 $0 \leq x'' < 2^k$，得到 $x' = \lfloor x / 2^k \rfloor$。进一步，可以观察到，算术右移位向量 $[x_{w-1}, x_{w-2}, \cdots, x_0]$ $k$ 位，得到位向量
$$
[x_{w-1}, \cdots, x_{k-1}, x_{w-1}, x_{w-2}, \cdots, x_k]
$$

它刚好就是将 $[x_{w-1}, x_{w-2}, \cdots, x_k]$ 从 $w-k$ 位符号扩展到 $w$ 位。因此，这个移位后的位向量就是 $x / 2^k$ 的补码表示。

我们可以通过对在执行算术右移之前加上一个适当的偏置量（biasing）这个值，来修正这种不合适的舍入。

**原理：除以 2 的幂的补码除法，向上舍入**

C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0 \leq k < w$，则当执行算术移位时，C 表达式 $(x + (1 << k) - 1) >> k$ 产生数值 $\lfloor x / 2^k \rfloor$。

图 2-30 说明在执行算术右移之前加上一个适当的偏置量是如何导致结果正确舍入的。在第 3 列，我们给出了 $-12340$ 加上偏置值之后的结果，低 $k$ 位（那些会向右移出的位）以斜体表示。我们可以看到，低 $k$ 位左边的位可能会加 1，也可能不会加 1。对于不需要舍入的情况 ($k = 1$)，加上偏置只影响那些被移掉的位。对于需要舍入的情况，加上偏置导致较高的位加 1，所以结果会向零舍入。

| $k$ | 偏量 | $-12340$ + 偏量 | $>> k$（二进制） | 十进制 | $-12340 / 2^k$ |
|-----|------|------------------|------------------|--------|----------------|
| 0   | 0    | -12340           | 1100111110011100 | -12340 | -12340.0       |
| 1   | 1    | -12339           | 1110011111001110 | -6170  | -6170.0        |
| 4   | 15   | -12325           | 1111100111110011 | -771   | -771.25        |
| 8   | 255  | -12085           | 1111111110011111 | -48    | -48.203125     |

> 图 2-30 补码除以 2 的幂（在右移之前加上一个偏量，结果就向零舍入了）

偏置技术利用如下属性：对于整数 $x$ 和 $y (y > 0)$，$\lfloor x / y \rfloor = \lfloor (x + y - 1) / y \rfloor$。例如，当 $x = -30$ 和 $y = 4$，我们有 $x + y - 1 = -27$，而 $\lfloor -30 / 4 \rfloor = -7 = \lfloor -27 / 4 \rfloor$。当 $x = -32$ 和 $y = 4$ 时，我们有 $x + y - 1 = -29$，而 $\lfloor -32 / 4 \rfloor = -8 = \lfloor -29 / 4 \rfloor$。

**推导：除以 2 的幂的补码除法，向上舍入**

查看 $\lfloor x / y \rfloor = \lfloor (x + y - 1) / y \rfloor$。假设 $x = qy + r$，其中 $0 \leq r < y$，得到 $(x + y - 1) / y = q + (r + y - 1) / y$，因此 $\lfloor (x + y - 1) / y \rfloor = q + \lfloor (r + y - 1) / y \rfloor$。当 $r = 0$ 时，后面一项等于 0，而当 $r > 0$ 时，等于 1。也就是说，通过给 $x$ 增加一个偏量 $y - 1$，然后再将除法向下舍入，当 $y$ 整除 $x$ 时，我们得到 $q$，否则，就得到 $q + 1$。

---

### 练习题 2.42

写一个函数 `div16`，对于整数参数 $x$ 返回 $x / 16$ 的值。你的函数不能使用除法、模运算、乘法、任何条件语句（if 或者 ?）、任何比较运算符（例如 <、> 或 =）或任何循环。你可以假设数据类型 `int` 是 32 位长，使用补码表示，而右移是算术右移。

---

### 练习题 2.43

在下面的代码中，我们省略了常数 $M$ 和 $N$ 的定义：

```c
#define M    /* Mystery number 1 */
#define N    /* Mystery number 2 */
int arith(int x, int y) {
    int result = 0;
    result = x*M + y/N; /* M and N are mystery numbers. */
    return result;
}
```

我们以某个 $M$ 和 $N$ 的值编译这段代码。编译器用我们讨论过的方法优化乘法和除法。下面是将产生的机器代码翻译回 C 语言的结果：

```c
/* Translation of assembly code for arith */
int optrath(int x, int y) {
    int t = x;
    x <<= 5;
    x -= t;
    if (y < 0) y += 7;
    y >>= 3; /* Arithmetic shift */
    return x+y;
}
```

$M$ 和 $N$ 的值是多少？

---

### 2.3.8 关于整数运算的最后思考

正如我们看到的，计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。我们还看到，补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与无符号算术相同的位级实现，这些运算包括加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常相似的位级行为。

我们看到了 C 语言中的某些规定可能会产生令人意想不到的结果，而这些结果可能是难以察觉或理解的缺陷的源头。我们特别看到了 `unsigned` 数据类型，虽然它概念上很简单，但可能导致即使是资深程序员都意想不到的行为。我们还看到这种数据类型会以出乎意料的方式出现，比如，当书写整数常数和当调用库函数时。

---

### 练习题 2.44

假设我们在对有符号值使用补码运算的 32 位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下：

```c
int x = foo(); /* Arbitrary value */
int y = bar(); /* Arbitrary value */
unsigned ux = x;
unsigned uy = y;
```

对于下面每个 C 表达式，1) 证明对于所有的 $x$ 和 $y$ 值，它都为真（等于 1）；或者 2) 给出使得它为假（等于 0）的 $x$ 和 $y$ 的值：

A. $(x > 0) || (x << 1 < 0)$  
B. $(x & 7) != 7 || (x << 29 < 0)$  
C. $(x * x) >= 0$  
D. $x < 0 || -x <= 0$  
E. $x + y == -x + -y$  
F. $x + y == uy + ux$  
G. $x * -y + uy * ux == -x$

---

### 2.4 浮点数

浮点表示对形如 $V = x \times 2^e$ 的有理数进行编码。它对执行涉及非常大的数字（$|V| >> 0$）、非常接近于 0（$|V| << 1$）的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。

直到 20 世纪 80 年代，每个计算机制造商都设计了自己的表示浮点数的规则，以及对浮点数执行运算的细节。另外，它们常常不会太多地关注运算的精确性，而把实现的速度和简便性看得比数字精确性更重要。

大约在 1985 年，这些情况随着 IEEE 标准 754 的推出而改变了，这是一个仔细制订的表示浮点数及其运算的标准。这项工作是从 1976 年开始由 Intel 赞助的，与 8087 的设计同时进行，8087 是一种为 8086 处理器提供浮点支持的芯片。他们请 William Kahan（加州大学伯克利分校的一位教授）作为顾问，帮助设计未来处理器浮点标准。他们支持 Kahan 加入一个 IEEE 资助的制订工业标准的委员会。这个委员会最终采纳的标准非常接近于 Kahan 为 Intel 设计的标准。目前，实际上所有的计算机都支持这个后来被称为 IEEE 浮点的标准。这大大提高了科学应用程序在不同机器上的可移植性。

**旁注 IEEE（电气和电子工程师协会）**

电气和电子工程师协会（IEEE，读做 “eye-c-triple-ee”）是一个包括所有电子和计算机技术的专业团体。它出版刊物，举办会议，并且建立委员会来定义标准，内容涉及从电力传输到软件工程。另一个 IEEE 标准的例子是无线网络的 802.11 标准。

在本节中，我们将看到 IEEE 浮点格式中数字是如何表示的。我们还将探讨舍入（rounding）的问题，即当一个数字不能被准确地表示为这种格式时，就必须向上调整或者向下调整。然后，我们将探讨加法、乘法和关系运算符的数学属性。许多程序员认为浮点数没意思，往坏了说，深奥难懂。我们将看到，因为 IEEE 格式是定义在一组小而一致的原则上，所以它实际上是相当优雅和容易理解的。

---

### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。首先，让我们来看看更熟悉的十进制表示法。十进制表示法使用如下形式的表示：

$$
d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}
$$

其中每个十进制数字 $d_i$ 的取值范围是 0～9。这个表达描述的数值 $d$ 定义如下：

$$
d = \sum_{i=-n}^{m} 10^i \times d_i
$$

数字权的定义与十进制小数点符号（‘.’）相关，这意味着小数点左边的数字的权是 10 的正幂，得到整数值，而小数点右边的数字的权是 10 的负幂，得到小数值。例如，$12.34_{10}$ 表示数字 $1 \times 10^1 + 2 \times 10^0 + 3 \times 10^{-1} + 4 \times 10^{-2} = 12 \frac{34}{100}$。

类似，考虑一个形如

$$
b_m b_{m-1} \cdots b_1 b_0 . b_{-1} b_{-2} \cdots b_{-n}
$$

的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，如图 2-31 所示。这种表示方法表示的数 $b$ 定义如下：

$$
b = \sum_{i=-n}^{m} 2^i \times b_i \tag{2.19}
$$

符号 ‘.’ 现在变为二进制的点，点左边的位的权是 2 的正幂，点右边的位的权是 2 的负幂。例如，$101.11_2$ 表示数字 $1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1 \times 2^{-1} + 1 \times 2^{-2} = 4 + 0 + 1 + \frac{1}{2} + \frac{1}{4} = 5 \frac{3}{4}$。

从等式 (2.19) 中可以很容易地看出，二进制小数点向左移动一位相当于这个数被 2 除。例如，$101.11_2$ 表示数 $5 \frac{3}{4}$，而 $10.111_2$ 表示数 $2 + 0 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} = 2 \frac{7}{8}$。类似，二进制小数点向右移动一位相当于将该数乘 2。例如 $1011.1_2$ 表示数 $8 + 0 + 2 + 1 + \frac{1}{2} = 11 \frac{1}{2}$。

注意，形如 $0.111\cdots_2$ 的数表示的是刚刚小于 1 的数。例如，$0.111111_2$ 表示 $\frac{63}{64}$，我们将用简单的表达式 $1 - \epsilon$ 来表示这样的数值。

假设我们仅考虑有限长度的编码，那么十进制表示法不能准确地表达 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似，小数的二进制表示法只能表示那些能够被写成 $x \times 2^n$ 的数。其他的值只能被近似地表示。例如，数字 $\frac{1}{5}$ 可以用十进制小数 0.20 精确表示。不过，我们并不能把它准确地表示为一个二进制小数，我们只能近似地表示它，增加二进制表示的长度可以提高表示的精度。

### 图 2-34 6 位浮点格式可表示的值（$k = 3$ 的阶码位和 $n = 2$ 的尾数位，偏置量是 3）

图 a) 展示了完整范围的数值分布，其中：

- 非规格化的数用蓝色圆点表示
- 规格化的数用三角形表示
- 无穷大用方块表示

图 b) 展示了在 $[-1.0, +1.0]$ 范围内的数值分布，包括非规格化数、规格化数和无穷大。

---

### 图 2-35 8 位浮点格式的非负值示例（$k = 4$ 的阶码位和 $n = 3$ 的小数位，偏置量是 7）

该格式将 8 位划分为：
- 4 位阶码（exp）
- 3 位小数（frac）

阶码字段被分为三个区域，用于描述三类数字：非规格化数、规格化数和无穷大。不同的列给出了阶码字段如何编码阶码 $E$，小数字段如何编码尾数 $M$，以及它们如何形成要表示的值 $V = 2^E \times M$。

从 0 自身开始，最靠近 0 的是非规格化数。这种格式的非规格化数的 $E = 1 - 7 = -6$，得到权 $2^E = \frac{1}{64}$。小数 $f$ 的值范围是 $0, \frac{1}{8}, \cdots, \frac{7}{8}$，从而得到数值 $V$ 的范围是 $0 \sim \frac{1}{64} \times \frac{7}{8} = \frac{7}{512}$。

| 描述 | 位表示 | 指数 | 小数 | 值 |
|------|--------|------|------|----|
|      |        | $e$ | $E$ | $2^E$ | $f$ | $M$ | $2^E \times M$ | $V$ | 十进制 |
| 0 | 0 0000 000 | 0 | -6 | $\frac{1}{64}$ | 0 | $\frac{0}{8}$ | $\frac{0}{512}$ | 0 | 0.0 |
| 最小的非规格化数 | 0 0000 001 | 0 | -6 | $\frac{1}{64}$ | $\frac{1}{8}$ | $\frac{1}{8}$ | $\frac{1}{512}$ | $\frac{1}{512}$ | 0.001953 |
|       | 0 0000 010 | 0 | -6 | $\frac{1}{64}$ | $\frac{2}{8}$ | $\frac{2}{8}$ | $\frac{2}{512}$ | $\frac{2}{512}$ | 0.003906 |
|       | 0 0000 011 | 0 | -6 | $\frac{1}{64}$ | $\frac{3}{8}$ | $\frac{3}{8}$ | $\frac{3}{512}$ | $\frac{3}{512}$ | 0.005859 |
|       | ... | ... | ... | ... | ... | ... | ... | ... | ... |
| 最大的非规格化数 | 0 0000 111 | 0 | -6 | $\frac{1}{64}$ | $\frac{7}{8}$ | $\frac{7}{8}$ | $\frac{7}{512}$ | $\frac{7}{512}$ | 0.013672 |
| 最小的规格化数 | 0 0001 000 | 1 | -6 | $\frac{1}{64}$ | 0 | $\frac{8}{8}$ | $\frac{8}{512}$ | $\frac{8}{512}$ | 0.015625 |
|       | 0 0001 001 | 1 | -6 | $\frac{1}{64}$ | $\frac{1}{8}$ | $\frac{9}{8}$ | $\frac{9}{512}$ | $\frac{9}{512}$ | 0.017578 |
|       | ... | ... | ... | ... | ... | ... | ... | ... | ... |
| 1 | 0 0111 000 | 7 | 0 | 1 | 0 | $\frac{8}{8}$ | 1 | 1 | 1.0 |
|       | 0 0111 001 | 7 | 0 | 1 | $\frac{1}{8}$ | $\frac{9}{8}$ | $\frac{9}{8}$ | $\frac{9}{8}$ | 1.125 |
|       | 0 0111 010 | 7 | 0 | 1 | $\frac{2}{8}$ | $\frac{10}{8}$ | $\frac{10}{8}$ | $\frac{10}{8}$ | 1.25 |
|       | ... | ... | ... | ... | ... | ... | ... | ... | ... |
| 最大的规格化数 | 0 1110 111 | 14 | 7 | 128 | $\frac{7}{8}$ | $\frac{15}{8}$ | $\frac{1920}{8}$ | $\frac{1920}{8}$ | 240.0 |
| 无穷大 | 0 1111 000 | — | — | — | — | — | — | — | $\infty$ |

---

### 图 2-36 非负浮点数的示例

该表展示了单精度和双精度浮点数的一些重要值及其表示。

| 描述 | exp | frac | 单精度 | 双精度 |
|------|-----|------|--------|--------|
|      |     |      | 值 | 十进制 | 值 | 十进制 |
| 0 | 00…00 | 0…00 | 0 | 0.0 | 0 | 0.0 |
| 最小的非规格化数 | 00…00 | 0…01 | $2^{-23} \times 2^{-126}$ | $1.4 \times 10^{-45}$ | $2^{-52} \times 2^{-1022}$ | $4.9 \times 10^{-324}$ |
| 最大非规格化数 | 00…00 | 1…11 | $(1 - \varepsilon) \times 2^{-126}$ | $1.2 \times 10^{-38}$ | $(1 - \varepsilon) \times 2^{-1022}$ | $2.2 \times 10^{-308}$ |
| 最小规格化数 | 00…01 | 0…00 | $1 \times 2^{-126}$ | $1.2 \times 10^{-38}$ | $1 \times 2^{-1022}$ | $2.2 \times 10^{-308}$ |
| 1 | 01…11 | 0…00 | $1 \times 2^0$ | 1.0 | $1 \times 2^0$ | 1.0 |
| 最大规格化数 | 11…10 | 1…11 | $(2 - \varepsilon) \times 2^{127}$ | $3.4 \times 10^{38}$ | $(2 - \varepsilon) \times 2^{1023}$ | $1.8 \times 10^{308}$ |

---

### 浮点数的一般性质说明

- 值 $+0.0$ 总有一个全为 0 的位表示。
- 最小的正非规格化值的位表示是由最低有效位为 1 而其他所有位为 0 构成的。它具有小数（和尾数）值 $M = f = 2^{-n}$ 和阶码值 $E = -2^{k-1} + 2$。因此它的数值是 $V = 2^{-n - 2^{k-1} + 2}$。
- 最大的非规格化数的位模式是由全为 0 的阶码字段和全为 1 的小数字段组成的。它具有小数（和尾数）值 $M = f = 1 - 2^{-n}$（我们写成 $1 - \varepsilon$）和阶码值 $E = -2^{k-1} + 2$。因此，数值 $V = (1 - 2^{-n}) \times 2^{-2^{k-1} + 2}$，这仅比最小的规格化值小一点。
- 最小的正规规格化值的位模式的阶码字段的最低有效位为 1，其他位全为 0。它的尾数值 $M = 1$，而阶码值 $E = -2^{k-1} + 2$。因此，数值 $V = 2^{-2^{k-1} + 2}$。
- 值 $1.0$ 的位表示的阶码字段除了最高有效位等于 1 以外，其他位都等于 0。它的尾数值是 $M = 1$，而它的阶码值是 $E = 0$。
- 最大的规格化数的位表示的符号位为 0，阶码的最低有效位等于 0，其他位等于 1。它的小数值 $f = 1 - 2^{-n}$，尾数 $M = 2 - 2^{-n}$（我们写作 $2 - \varepsilon$）。它的阶码值 $E = 2^{k-1} - 1$，得到数值 $V = (2 - 2^{-n}) \times 2^{2^{k-1} - 1} = (1 - 2^{-n-1}) \times 2^{2^{k-1}}$。

---

### 整数转浮点表示示例

以整数 12345 为例，其二进制表示为 $[11000000111001]_2$。通过将二进制小数点右移 13 位，我们得到 $12345 = 1.1000000111001_2 \times 2^{13}$。

为了构造 IEEE 单精度浮点表示：
- 丢弃开头的 1，末尾添加 10 个 0，构成小数字段：$[1000001110010000000000]$
- 阶码为 13 加上偏置量 127，得到 140，其二进制表示为 $[10001100]_2$
- 加上符号位 0，最终得到浮点表示：$[0\ 10001100\ 10000011100100000000000]$

即：
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

对应关系如下：

```
         4 6 4 0 4 0 0
00000000000000000000000000000000
          0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
01000110010000011100100000000000
```

可以看到，相关的区域对应于整数的低位，刚好在等于 1 的最高有效位之前停止（这个位就是隐含的开头的位 1），和浮点表示的小数部分的高位是相匹配的。

---

### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。对于值 $x$，我们一般想用一种系统的方法，能找到“最接近的”匹配值 $x'$，它可以用期望的浮点形式表示出来。这就是舍入（rounding）运算的任务。

一个关键问题是：在两个可能值的中间确定舍入方向。例如，如果有 1.50 美元，想把它舍入到最近的美元数，应该是 1 美元还是 2 美元？一种可选择的方法是维持实际数字的下界和上界。我们可以定义可能的值 $x^-$ 和 $x^+$，使得 $x$ 的值位于它们之间：$x^- \leq x \leq x^+$。

IEEE 浮点格式定义了四种不同的舍入方式。默认的是找到最接近的匹配，而其他三种可用于计算上界和下界。

#### 四种舍入方式

| 方式 | 示例 |
|------|------|
| 向偶数舍入 | 1.40 → 1，1.60 → 2，1.50 → 2，2.50 → 2，-1.50 → -2 |
| 向零舍入 | 1.40 → 1，1.60 → 1，1.50 → 1，2.50 → 2，-1.50 → -1 |
| 向下舍入 | 1.40 → 1，1.60 → 1，1.50 → 1，2.50 → 2，-1.50 → -2 |
| 向上舍入 | 1.40 → 2，1.60 → 2，1.50 → 2，2.50 → 3，-1.50 → -1 |

向偶数舍入法的目标是避免统计偏差。例如，在 50% 的时间里向上舍入，50% 的时间里向下舍入。这种方法在二进制小数上同样适用。我们将最低有效位的值 0 认为是偶数，值 1 认为是奇数。

只有对形如 $XX\cdots X.YY\cdots Y100\cdots$ 的二进制位模式的数，这种舍入方式才有效，其中 $X$ 和 $Y$ 表示任意位置，最右边的 $Y$ 是要被舍入的位置。只有这种位模式表示在两个可能的结果正中间的值。

例如，考虑 10.0001₂ 向下舍入到 10.00₂，10.0010₂ 向上舍入到 10.01₂，10.1100₂ 向上舍入到 10.11₂，而 10.1010₂ 向下舍入到 10.10₂，因为这些值是两个可能值的中间值，并且我们倾向于使最低有效位为零。

---

### 2.4.5 浮点运算

IEEE 标准指定了一个简单的规则，来确定诸如加法和乘法这样的算术运算的结果。把浮点值 $x$ 和 $y$ 看成实数，而某个运算 $\oplus$ 定义在实数上，计算将产生 $Round(x \oplus y)$，这是对实际运算的精确结果进行舍入后的结果。

在实际中，浮点单元的设计者使用一些聪明的小技巧来避免执行这种精确的计算，因为计算只要精确到能够保证得到一个正确的舍入结果就可以了。当参数中有一个是特值（如 $-0$、$+\infty$ 或 $NaN$）时，IEEE 标准定义了一些使之更合理的规则。例如，定义 $1 / -0$ 将产生 $-\infty$，而定义 $1 / +0$ 会产生 $+\infty$。

IEEE 标准中指定浮点运算行为方法的一个优势在于，它可以独立于任何具体的硬件或软件实现。因此，我们可以检查它的抽象数学属性，而不必考虑它实际上是如何实现的。

前面我们看到了整数（包括无符号和补码）也形成了阿贝尔群，但是我们还必须考虑舍入对这些属性的影响。我们将 $x + y$ 定义为 $Round(x + y)$。这个运算的定义针对 $x$ 和 $y$ 的所有取值，但是虽然 $x$ 和 $y$ 都是实数，由于舍入，该运算可能到无穷值。

对于所有 $x$ 和 $y$ 的值，这个运算是可交换的，也就是 $x + y = y + x$。另一方面，这个运算是不可结合的。例如，使用单精度浮点，表达式 $3.14 + (1e10 - 1e10)$ 得出值 3.14，作为阿贝尔群，大多数值在浮点加法下都有逆元，也就是说 $x + (-x) = 0$。无穷（因为 $+\infty - \infty = NaN$）和 $NaN$ 是例外情况，因为对于任何 $x$，都有 $NaN + x = NaN$。

浮点加法不具有结合性，这是缺少的最重要的群属性。对于科学计算程序员和编译器编写者来说，这具有重要的含义。例如，假设一个编译器给定了如下代码片段：

```c
x = a + b + c;
y = b + c + d;
```

编译器可能试图通过产生下列代码来省去一个浮点加法：

```c
t = b + c;
x = a + t;
y = t + d;
```

然而，对于 $x$ 来说，这个计算可能会产生与原始值不同的值，因为它使用了加法运算的不同的结合方式。在大多数应用中，这种差异小得无关紧要。不幸的是，编译器无法知道在效率和忠实于原始程序的确切行为之间，使用者愿意做出什么样的选择。结果是，编译器倾向于保守，避免任何对功能产生影响的优化，即使是很轻微的影响。

另一方面，浮点加法满足了单调性属性：如果 $a \geq b$，那么对于任何 $a$、$b$ 以及 $x$ 的值，除了 $NaN$，都有 $x + a \geq x + b$。无符号或补码加法不具有这个属性（和整数加法的属性）。

浮点乘法也遵循通常乘法所具有的许多属性。我们定义 $x * y$ 为 $Round(x \times y)$。这个运算在乘法中是封闭的（虽然可能产生无穷大或 $NaN$），它是可交换的，而且它的乘法单位元为 1.0。

另一方面，由于可能发生溢出，或者由于舍入而失去精度，它不具有可结合性。例如，单精度浮点情况下，表达式 $(1e20 * 1e20) * 1e-20$ 求值为 $+\infty$，而 $1e20 * (1e20 * 1e-20)$ 将得出 $1e20$。

另外，浮点乘法在加法上不具备分配性。例如，单精度浮点情况下，表达式 $1e20 * (1e20 - 1e20)$ 求值为 0.0，而 $1e20 * 1e20 - 1e20 * 1e20$ 会得出 $NaN$。

另一方面，对于任何 $a$、$b$ 和 $c$，并且 $a$、$b$ 和 $c$ 都不等于 $NaN$，浮点乘法满足下列单调性：

$$
a \geq b \text{ 且 } c \geq 0 \Rightarrow a * c \geq b * c
$$
$$
a \geq b \text{ 且 } c \leq 0 \Rightarrow a * c \leq b * c
$$

此外，我们还可以保证，只要 $a \neq NaN$，就有 $a * 0 \geq 0$。

像我们先前所看到的，无符号或补码的乘法没有这些单调性属性。

对于科学计算程序员和编译器编写者来说，缺乏结合性和分配性是很严重的问题。即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。

---

### 2.4.6 C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数据类型：`float` 和 `double`。在支持 IEEE 浮点格式的机器上，这些数据类型对应于单精度和双精度浮点。另外，这类机器使用向偶数舍入的舍入方式。

不幸的是，因为 C 语言标准不要求机器使用 IEEE 浮点，所以没有标准的方法来改变舍入方式或者得到诸如 $-0$、$+\infty$、$-\infty$ 或者 $NaN$ 之类的特值。大多数系统提供 `include(*.h)` 文件和读取这些特征的过程库，但是细节随系统不同而不同。例如，当程序文件中出现下列句子时，GNU 编译器 GCC 会定义程序常数 `INFINITY`（表示 $+\infty$）和 `NAN`（表示 $NaN$）：

```c
#define _GNU_SOURCE 1
#include <math.h>
```

不能使用任何 `include` 文件（例如 `math.h`），但你能利用这样一个事实：双精度能够表示的最大有限数，大约是 $1.8 \times 10^{308}$。

当在 `int`、`float` 和 `double` 之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设 `int` 是 32 位的）：

- 从 `int` 转换成 `float`，数字不会溢出，但是可能被舍入。
- 从 `int` 或 `float` 转换成 `double`，因为 `double` 有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从 `double` 转换成 `float`，因为范围要小一些，所以值可能溢出成 $+\infty$ 或 $-\infty$。另外，由于精确度较小，它还可能被舍入。
- 从 `float` 或者 `double` 转换成 `int`，值将会向零舍入。例如，1.999 将被转换成 1，而 -1.999 将被转换成 -1。进一步来说，值可能会溢出。C 语言标准没有对这种情况指定固定的结果。与 Intel 兼容的微处理器指定位模式 `[10...00]`（字长为 $w$ 时的 $TMin_w$）为整数不确定（integer indefinite）值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式 `(int)+1e10` 会得到 -21483648，即从一个正值变成了一个负值。

---

### 旁注 Ariane 5——浮点溢出的高昂代价

将大的浮点数转换成整数是一种常见的程序错误来源。1996 年 6 月 4 日，Ariane 5 火箭初次航行，一个错误使其发生了灾难性的后果。发射后仅仅 37 秒钟，火箭偏离了它的飞行路径，解体并爆炸。火箭上载有价值的 5 亿美元的通信卫星。

后来的调查 [73, 33] 显示，控制惯性导航系统的计算机向控制引擎喷嘴的计算机发送了一个无效数据。它没有发送飞行控制信息，而是送出了一个诊断位模式，表明在将一个 64 位浮点数转换成 16 位有符号整数时，产生了溢出。

溢出的值测量的是火箭的水平速度，这时早先的 Ariane 4 火箭所能达到的速度高出了 5 倍。在设计 Ariane 4 火箭软件时，他们小心地分析了这些数字值，并且确定水平速度决不会超出一个 16 位数的表示范围。不幸的是，他们在 Ariane 5 火箭的系统中简单地重用了这一部分，而没有检查它所基于的假设。

---

### 2.5 小结

计算机将信息编码为位（比特），通常组织成字节序列。不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和名字数据中的字节顺序时使用不同的约定。

C 语言的计算可以包含多种不同字长和数字编码的实现。64 位字长的机器逐渐普及，并正在取代统治市场长达 30 多年的 32 位机器。由于 64 位机器编程的程序，我们的重点就放在区分 32 位和 64 位程序，而不是机器本身。64 位程序的优势是可以突破 32 位程序具有的 4GB 地址限制。

大多数机器对整数使用补码编码，而对浮点数使用 IEEE 标准 754 编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运行的程序员来说，是很重要的。

在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数 C 语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个 $w$ 位的值，这种行为是由函数 $T2U_w$ 和 $U2T_w$ 来描述的。C 语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。

由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会下溢。

和大多数其他程序语言一样，C 语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式 $x * x$ 能够得出负数。但是，无符号和补码的运算都满足整数运算的许多其他属性，包括结合性、交换性和分配性。这就允许编译器做很多的优化。例如，用 $(x << 3) - x$ 取代表达式 $7 * x$ 时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以 2 的幂之间的关系。

我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算，$-x + 1$ 等价于 $-x$。另一个例子，假设我们想要一个形如 $[0, \cdots, 0, 1, \cdots, 1]$ 的位模式，由 $w - k$ 个 0 后面紧跟着 $k$ 个 1。

























