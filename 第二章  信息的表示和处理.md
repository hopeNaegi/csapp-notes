# 第二章  信息的表示和处理

## 2.1 信息存储

### 2.1.1 十六进制表示法及进制的转换

一个字节由8位组成。以0x开头的数字被认为是十六进制的值，数字中字母大小写不影响。

十六进制转换为二进制
将每一位数字转换为十进制后展开为四位二进制数字。
二进制转换为十六进制
从右向左四位一分隔，最左边不够的用0补齐，按照8421的权重求和后得到对应十六进制数。


二进制数为2^n时的进制转换
1.转换为十进制数
1后面跟n个0
2.转换为十六进制数
n=i+4j，则为2^i后面跟j个0


十进制转化为十六进制
将原数不断除以16，得到余数后由前向后由低到高排列即可
十六进制转换为十进制
根据不同位的权重加权求和即可。

### 2.1.2 字数据大小
字长决定指针数据的标称大小
| 项目 | 32 位系统 | 64 位系统 |
|------|----------|----------|
| 字长（word size） | 32 位 | 64 位 |
| 指针大小 | 4 字节 | 8 字节 |
| 地址表示范围 | 0 ～ 0xFFFFFFFF（4GB） | 0 ～ 0xFFFFFFFFFFFFFFFF（16EB） |
| 同一指针变量 `p` 的 `sizeof(p)` | 4 | 8 |
例如将32位程序的int指针挪用到64位机器上时会崩溃，int类型只有4字节大，而64位下的指针有8字节大。

我们将程序称为 "32 位程序" 或 "64 位程序 " 时，区别在于该程序是如何编译的，
而不是其运行的机器类型。
关键字的顺序可以改变。
### 2.1.3 寻址和字节顺序
对于跨越多字节的的程序对象，需要建立两个规则：1.这个对象的地址是什么2.如何在内存中排列这些字节。
第一，多字节对象都被存储为连续的字节序列，地址为所用字节的最小地址。
第二，有两种排列方法。一种将最低有效字节排在前，为小端法，另一种将最高有效字节排在前，为大端法。
字节顺序在三种情况下会显得重要:
第一，大小端法机器互传时需要进行转换，否则字节会反序；
第二，阅读机器级程序，选对应顺序；
第三，规避正常的类型时：

| 行号 | 代码 |
| ---- | ---- |
| 1    | `#include <stdio.h>` |
| 2    | |
| 3    | typedef[^1] unsigned char *byte_pointer; |
| 4    | |
| 5    | `void show_bytes(byte_pointer start, size_t len) {` |
| 6    | `    size_t i;` |
| 7    | `    for (i = 0; i < len; i++)` |
| 8    | `        printf(" %.2x", start[i]);` |
| 9    | `    printf("\n");` |
| 10   | `}` |
| 11   | |
| 12   | void show_int(int x)[^2] { |
| 13   | `    show_bytes((byte_pointer) &x[^3], sizeof(int));` |
| 14   | `}` |
| 15   | |
| 16   | `void show_float(float x) {` |
| 17   | `    show_bytes((byte_pointer) &x, sizeof(float));` |
| 18   | `}` |
| 19   | |
| 20   | `void show_pointer(void *x) {` |
| 21   | `    show_bytes((byte_pointer) &x, sizeof(void *));` |
| 22   | `}` |
[^1]:用法没有本质区别，只是提升了代码的可读性
[^2]:这些函数都是强制转换类型为byte_pointer
[^3]:printf第一个参数是格式串，%开头则是表示如何格式化下一个参数。例如：
| 格式符 | 含义 |
|--------|------|
| `%d`   | 输出十进制整数 |
| `%f`   | 输出浮点数 |
| `%s`   | 输出字符串 |
| `%x`   | 输出十六进制整数（小写） |
| `%X`   | 输出十六进制整数（大写） |
| `%c`   | 输出单个字符 |

printf("%.2x", 0x3);   // 输出: "03"

printf("%.2x", 0x15);  // 输出: "15"

printf("%.2x", 0x0);   // 输出: "00"
> .2是精度修饰符





